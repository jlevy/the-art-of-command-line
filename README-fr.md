üåç
*[ƒåe≈°tina](README-cs.md) ‚àô [English](README.md) ‚àô [Espa√±ol](README-es.md) ‚àô [Fran√ßais](README-fr.md) ‚àô [Italiano](README-it.md) ‚àô [Êó•Êú¨Ë™û](README-ja.md) ‚àô [ÌïúÍµ≠Ïñ¥](README-ko.md) ‚àô [Portugu√™s](README-pt.md) ‚àô [–†—É—Å—Å–∫–∏–π](README-ru.md) ‚àô [Sloven≈°ƒçina](README-sl.md) ‚àô [–£–∫—Ä–∞—ó–Ω—Å—å–∫–∞](README-uk.md) ‚àô [‰∏≠Êñá](README-zh.md)*

# L'art de la ligne de commande

[![Join the chat at https://gitter.im/jlevy/the-art-of-command-line](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/jlevy/the-art-of-command-line?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)

- [M√©ta](#m√©ta)
- [Notions de base](#notions-de-base)
- [Utilisation quotidienne](#utilisation-quotidienne)
- [Traitement des fichiers et des donn√©es](#traitement-des-fichiers-et-des-donn√©es)
- [D√©bogage du syst√®me](#d√©bogage-du-syst√®me)
- [Unilignes](#unilignes)
- [Obscures mais utiles](#obscures-mais-utiles)
- [Uniquement OS X](#uniquement-os-x)
- [Autres ressources](#autres-ressources)
- [Avertissement](#avertissement)


![curl -s 'https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md' | egrep -o '`\w+`' | tr -d '`' | cowsay -W50](cowsay.png)

La ma√Ætrise de la ligne de commande est une comp√©tence souvent n√©glig√©e ou consid√©r√©e √©sot√©rique, pourtant elle am√©liore de fa√ßon √©vidente et subtile votre habilit√© et votre productivit√© en tant qu'ing√©nieur.
Ceci est une s√©lection de notes et d'astuces sur l'utilisation de la ligne de commande que nous avons trouv√©es utiles en travaillant avec Linux.
Certaines sont √©l√©mentaires, d'autres sont assez sp√©cifiques, complexes ou obscures.
Cette page n'est pas bien longue, mais si vous pouvez retenir et vous servir de tout ce qui s'y trouve, alors vous saurez beaucoup de choses.

Ce document est le fruit du travail de [nombreux auteurs et traducteurs](AUTHORS.md).
Une partie de celui-ci a √©t√© [initialement](http://www.quora.com/What-are-some-lesser-known-but-useful-Unix-commands) [publi√©e](http://www.quora.com/What-are-the-most-useful-Swiss-army-knife-one-liners-on-Unix) sur [Quora](http://www.quora.com/What-are-some-time-saving-tips-that-every-Linux-user-should-know), mais il se trouve maintenant sur GitHub, o√π des personnes plus comp√©tentes que l'auteur originel ont apport√© de nombreuses am√©liorations.
[**Merci de contribuer**](/CONTRIBUTING.md) si vous voyez une erreur ou quelque chose qui pourrait √™tre am√©lior√© !


## M√©ta

Contexte :

- Ce guide est destin√© aux d√©butants et aux utilisateurs chevronn√©s.
Les objectifs sont l'*envergure* (tout est important), la *sp√©cificit√©* (donner des exemples concrets des cas les plus courants) et la *concision* (√©viter tout ce qui n'est pas essentiel et les digressions disponibles facilement ailleurs).
Chaque astuce est indispensable dans certaines situations ou fait gagner beaucoup de temps par rapport aux solutions alternatives.
- Il est √©crit pour Linux, √† l'exception de la section ¬´ [Uniquement OS X](#uniquement-os-X) ¬ª.
Beaucoup d'items s'appliquent ou peuvent √™tre install√©s sur d'autres Unices ou Mac OS (ou m√™me Cygwin).
- L'accent est mis sur l'utilisation int√©ractive de Bash, bien que de nombreuses astuces s'appliquent aux autres shells et √† l'√©criture de scripts en Bash.
- Il inclut les commandes ¬´ standard ¬ª d'Unix aussi bien que celles qui n√©cessitent l'installation de paquets sp√©ciaux &mdash; tant qu'ils sont suffisamment importants pour m√©riter d'√™tre mentionn√©s.

Remarques :

- Afin que le guide tienne sur une seule page, du contenu est implicitement inclus par r√©f√©rence.
Vous √™tes suffisamment intelligents pour rechercher des renseignements ailleurs une fois que vous avez l'id√©e ou la commande √† googler.
Utilisez `apt-get`, `yum`, `dnf`, `pacman`, `pip` ou `brew` (selon votre distribution ou OS) pour installer de nouveaux programmes.
- Allez sur [Explainshell](http://explainshell.com) pour obtenir de l'aide √† propos des commandes, options, tubes, etc.


## Notions de base

- Apprenez les bases de Bash.
En fait, tapez `man bash` et parcourez toute la page&#8239;; elle est relativement facile √† suivre et pas si longue.
Les shells alternatifs peuvent √™tre int√©ressants, mais Bash est puissant et disponible partout (apprendre *seulement* zsh, fish, etc., bien que cela soit tentant sur votre ordinateur portable, vous limite dans bien des situations, comme par exemple lors de l'utilisation de vrais serveurs).

- Apprenez √† bien utiliser au moins un √©diteur en mode texte.
Id√©alement Vim (`vi`), car il n'a pas vraiment de concurrent lorsqu'il s'agit d'√©diter inopin√©ment un texte dans un terminal  (m√™me si la plupart du temps vous utilisez Emacs, un gros EDI ou l'un de ces nouveaux √©diteurs √† la mode).

- Sachez comment lire une documentation avec `man` (pour les curieux, `man man` liste les sections avec leur num√©ro, par exemple 1 pour les commandes ¬´&nbsp;normales&nbsp;¬ª , 5 pour les formats des fichiers et les conventions, et 8 pour tout ce qui concerne l'administration syst√®me).
Trouvez les pages de manuel avec `apropos`.
Sachez que certaines commandes ne sont pas des ex√©cutables, mais des commandes internes de Bash et que vous pouvez obtenir de l'aide √† leur sujet avec `help` et `help -d`.

- Apprenez √† rediriger les entr√©es et sorties au moyen de `>` et `<`, et √† cr√©er des tubes avec `|`.
Sachez que `>` √©crase le fichier de sortie et `>>` sert √† ajouter.
Renseignez-vous sur stdout et stderr.

- Apprenez au sujet de l'expansion des noms de fichiers avec `*` (et peut-√™tre `?` et `[`...`]`), des m√©canismes de citation, et de la diff√©rence entre les guillemets `"` et les apostrophes `'` (voir ci-dessous).

- Familiarisez-vous avec la gestion des processus avec Bash&nbsp;: `&`, **ctrl-z**, **ctrl-c**, `jobs`, `fg`, `bg`, `kill`, etc.

- Apprenez `ssh` et les principes de l'authentification sans mot de passe √† l'aide de `ssh-agent`, `ssh-add`, etc.

- Les bases de la gestion des fichiers&nbsp;: `ls` et `ls -l` (en particulier, apprenez la signification de chacune des colonnes de `ls -l`), `less`, `head`, `tail` et `tail -f` (ou mieux, `less +F`), `ln` et `ln -s` (apprenez les diff√©rences et les avantages des liens durs par rapport aux liens symboliques), `chown`, `chmod`, `du` (pour un rapide r√©sum√© de l'espace disque occup√©&nbsp;: `du -hs *`).
Pour la gestion du syst√®me de fichiers&nbsp;: `df`, `mount`, `fdisk`, `mkfs`, `lsblk`.
Apprenez ce qu'est un inode (`ls -i` ou `df -i`).

- Les bases de l'administration r√©seau&nbsp;: `ip` ou `ifconfig`, `dig`.

- Apprenez les expressions r√©guli√®res et les diff√©rents drapeaux de `grep` et `egrep`.
Les options `-i`, `-o`, `-v`, `-A`, `-B` et `-C` sont bonnes √† conna√Ætre.

- Apprenez √† utiliser `apt-get`, `yum`, `dnf` ou `pacman` (selon la distribution) pour trouver et installer des paquets.
Assurez-vous d'avoir `pip` pour installer des outils en ligne de commande √©crits en Python (quelques-uns ci-dessous sont plus faciles √† installer avec `pip`).


## Utilisation quotidienne

- En Bash, utilisez **Tab** pour compl√©ter les arguments ou lister toutes les commandes disponibles, et **ctrl-r** pour rechercher dans l'historique des commandes (tapez pour rechercher, appuyez sur **ctrl-r** plusieurs fois pour parcourir les diff√©rentes correspondances, appuyez sur **Enter** pour ex√©cuter la commande trouv√©e ou sur la fl√®che droite pour l'√©diter).

- En Bash, utilisez **ctrl-w** pour effacer le mot pr√©c√©dent et **ctrl-u** pour effacer le contenu de la ligne jusqu'au curseur.
Utilisez **alt-b** et **alt-f** pour se d√©placer mot par mot, **ctrl-a** pour d√©placer le curseur au d√©but de la ligne, **ctrl-e** pour d√©placer le curseur √† la fin de la ligne, **ctrl-k** pour effacer depuis le curseur jusqu'√† la fin de la ligne, **ctrl-l** pour effacer l'√©cran.
Voir `man readline` pour la liste des raccourcis clavier par d√©fault de Bash.
Il y en a beaucoup.
Par exemple **alt-.** fait d√©filer les arguments pr√©c√©dents et **alt-*** d√©veloppe un glob.

- Sinon, si vous adorez les combinaisons de touches dans le style vi, utilisez `set -o vi` (`set -o emacs` pour revenir en arri√®re).

- Pour √©diter de longues commandes, apr√®s avoir configur√© votre √©diteur (par exemple `export EDITOR=vim`), **ctrl-x** **ctrl-e** (**escape-v** dans le style vi) ouvre l'√©diteur pour √©diter la commande courante.

- Pour voir les commandes r√©centes, `history`.
Il y a aussi beaucoup d'abr√©viations telles que `!$` (dernier argument) et `!!` (derni√®re commande), bien que celles-ci soient souvent remplac√©es par **ctrl-r** et **alt-.**.

- Pour revenir au r√©pertoire de travail pr√©c√©dent&nbsp;: `cd -`.

- Si vous √™tes au milieu de la saisie d'une commande mais que vous changez d'avis, tapez **alt-#** pour ajouter `#` au d√©but de la ligne et l'entrer comme un commentaire (ou utilisez **ctrl-a**, **#**, **enter**).
Vous pouvez alors y revenir plus tard √† l'aide de la commande history.

- Utilisez `xargs` (ou `parallel`).
C'est tr√®s puissant.
Remarquez que vous pouvez contr√¥ler le nombre d'items √† ex√©cuter par ligne (`-L`) ainsi que la parall√©lisation (`-P`).
Si vous n'√™tes pas s√ªr d'avoir fait ce qu'il faut, utilisez d'abord `xargs echo`.
L'option `-I{}` est √©galement pratique.
Exemples&nbsp;:
```bash
      find . -name '*.py' | xargs grep some_function
      cat hosts | xargs -I{} ssh root@{} hostname
```

- `pstree -p` fournit un affichage utile des processus sous la forme d'un arbre.

- `pgrep` et `pkill` pour rechercher ou envoyer un signal √† des processus en fonction de leur nom (`-f` est utile).

- Connaissez les diff√©rents signaux que vous pouvez envoyer aux processus.
Par exemple, pour suspendre l'ex√©cution d'un processus, utilisez `kill -STOP [pid]`.
Pour la liste compl√®te, consultez `man 7 signal`.

- Utilisez `nohup` ou `disown` pour qu'un processus en arri√®re-plan reste actif ind√©finiment.

- V√©rifiez quels sont les processus qui √©coutent √† l'aide de `netstat -lntp` ou `ss -plat` (pour TCP; ajoutez `-u` pour UDP).

- Voyez √©galement `lsof` pour la liste des *sockets* et fichiers ouverts.

- Voyez `uptime` ou `w` pour savoir depuis combien de temps le syst√®me fonctionne.

- Utilisez `alias` pour cr√©er des raccourcis vers les commandes fr√©quemment utilis√©es.
Par exemple, `alias ll='ls -latr'` cr√©e un nouvel alias `ll`.

- Comprennez qu'il convient d'√™tre prudent lorsque des variables et des noms de fichiers contiennent des espaces.
Mettez vos variables entre guillemets, par exemple `"$FOO"`. 
Pr√©f√©rez les options `-0` ou `-print0` qui permettent de d√©limiter les noms des fichiers avec le caract√®re nul, par exemple `locate -0 pattern | xargs -0 ls -al` ou `find / -print0 -type d | xargs -0 ls -al`.
Pour it√©rer sur des noms de fichiers contenant des espaces dans une boucle for, positionnez la variable IFS avec le caract√®re de retour √† la ligne √† l'aide de `IFS=$'\n'`.

- Dans les scripts Bash, utilisez `set -x` (ou la variante `set -v` qui enregistre les entr√©es brutes, y compris les variables non r√©f√©renc√©es et les commentaires) pour l'affichage d'informations de d√©bogage.
Utilisez les modes stricts √† moins que vous ayez une bonne raison de ne pas le faire&nbsp;: utilisez `set -e` pour interrompre le script en cas d'erreur (code de sortie non nul).
Utilisez `set -u` pour d√©tecter l'utilisation d'une variable non initialis√©e.
Envisagez aussi `set -o pipefail` pour d√©tecter les erreurs dans les tubes (cependant lisez-en plus si vous l'utilisez car ce sujet est un peu d√©licat).
Pour des scripts plus compliqu√©s, servez-vous √©galement de `trap` pour intercepter EXIT ou ERR.
Une bonne habitude est de commencer un script comme cela, ce qui lui permettra de d√©tecter les erreurs courantes, de s'interrompre et d'afficher un message&nbsp;:
```bash
      set -euo pipefail
      trap "echo 'error: Script failed: see failed command above'" ERR
```

- Dans les scripts en Bash, les sous-shells (plac√©s entre parenth√®ses) sont commodes pour grouper des commandes.
Un exemple classique consiste √† se d√©placer temporairement dans un autre r√©pertoire de travail&nbsp;:
```bash
      # faire quelque chose dans le r√©pertoire courant
      (cd /some/other/dir && other-command)
      # continue dans le r√©pertoire original
```

- Remarquez qu'en Bash il y a de nombreux types d'expansion des variables.
V√©rifier l'existence d'une variable&nbsp;: `${name:?error message}`.
Par exemple, si un script en Bash exige un unique argument, il vous suffit d'√©crire `input_file=${1:?usage: $0 input_file}`.
L'expansion arithm√©tique&nbsp;: `i=$(( (i + 1) % 5 ))`. Suites&nbsp;: `{1..10}`. Suppression de sous-cha√Ænes&nbsp;: `${var%suffix}` et `${var#prefix}`. Par exemple,  si `var=foo.pdf`, alors `echo ${var%.pdf}.txt` affiche `foo.txt`.

- L'expansion des accolades avec `{`...`}` √©vite de retaper des textes similaires et automatise les combinaisons d'√©l√©ments de listes.
C'est utile dans des exemples comme  `mv foo.{txt,pdf} some-dir` (qui d√©place les deux fichiers), `cp somefile{,.bak}` (√©quivalent √† `cp somefile somefile.bak`) ou `mkdir -p test-{a,b,c}/subtest-{1,2,3}` (qui engendre toutes les combinaisons possibles et cr√©e une arborescence de r√©pertoires).

- La sortie d'une commande peut √™tre trait√©e comme un fichier √† l'aide de `<(some command)`.
Par exemple, pour comparer le fichier local `/etc/hosts` avec un fichier distant&nbsp;:
```sh
      diff /etc/hosts <(ssh somehost cat /etc/hosts)
```

- Renseignez-vous √† propos des ¬´ here documents ¬ª avec Bash, comme dans `cat <<EOF ...`.

- En Bash, redirigez √† la fois la sortie standard et la sortie des erreurs √† l'aide de `some-command > logfile 2>&1` ou `some-command &>logfile`.
Souvent, pour s'assurer qu'une commande ne laisse pas un descripteur de fichier ouvert sur l'entr√©e standard, l'attachant au terminal dans lequel vous vous trouvez, une bonne pratique consiste √† ajouter `</dev/null`.

- Utilisez `man ascii` pour une bonne table ASCII avec les valeurs d√©cimales et hexad√©cimales.
Pour des informations g√©n√©rales sur l'encodage, `man unicode`, `man utf-8` et `man latin1` sont utiles.

- Utilisez `screen` ou [`tmux`](https://tmux.github.io/) pour multiplexer une fen√™tre de terminal, particuli√®rement utile pour des sessions SSH distantes, et pour d√©tacher et rattacher une session.
`byobu` peut am√©liorer screen ou tmux en fournissant plus d'informations et une gestion plus facile.
Une alternative plus l√©g√®re pour la persistance des sessions seulement est `dtach`.

- Il est utile de savoir comment cr√©er un tunnel SSH avec `-L` ou `-D` (et occasionnellement `-R`), par exemple pour acc√©der √† des sites web √† partir d'un serveur distant.

- Il peut √™tre int√©ressant d'effectuer quelques optimisations √† votre configuration de ssh&#8239;; par exemple, le fichier `~/.ssh/config` contient des param√®tres pour √©viter les pertes de connexion dans certains environnements r√©seaux, pour utiliser la compression (ce qui est utile avec scp sur des connexions √† faible bande passante), et pour le multiplexage de canaux vers le m√™me serveur avec un fichier de contr√¥le local&nbsp;:
```
      TCPKeepAlive=yes
      ServerAliveInterval=15
      ServerAliveCountMax=6
      Compression=yes
      ControlMaster auto
      ControlPath /tmp/%r@%h:%p
      ControlPersist yes
```

- Quelques autres options relatives √† ssh sont sensibles pour la s√©curit√© et ne devraient √™tre activ√©es qu'avec la plus grande prudence. Par exemple, sur des sous-r√©seaux, des h√¥tes ou des r√©seaux s√ªrs&nbsp;: `StrictHostKeyChecking=no`, `ForwardAgent=yes`.

- Envisagez [`mosh`](https://mosh.mit.edu/) comme une alternative √† ssh qui utilise UDP, √©vitant ainsi les pertes de connexion et ajoutant du confort en situation de mobilit√© (exige une installation c√¥t√© serveur).

- Pour obtenir les permissions d'un fichier en octal, utile pour configurer le syst√®me mais non fournit par `ls`, utilisez quelque chose comme
```sh
      stat -c '%A %a %n' /etc/timezone
```

- Pour une s√©lection int√©ractive de valeurs issues de la sortie d'une commande, utilisez [`percol`](https://github.com/mooz/percol) ou [`fzf`](https://github.com/junegunn/fzf).

- Pour int√©ragir avec les fichiers provenant de la sortie d'une commande (p.&nbsp;ex. `git`), utilisez `fpp` ([PathPicker](https://github.com/facebook/PathPicker)).


- Cr√©ez un simple serveur web pour partager les fichiers du r√©pertoire courant (et ses sous-r√©pertoires) avec `python -m SimpleHTTPServer 7777` (port 7777 et Python 2)  et `python -m http.server 7777` (port 7777 et Python 3).

- Pour ex√©cuter une commande avec des privil√®ges, utilisez `sudo` (en tant que root) ou `sudo -u` (en tant qu'un autre utilisateur).
Utilisez `su` ou `sudo bash` pour ex√©cuter un shell sous cette utilisateur.
Utilisez `su -` pour simuler une nouvelle connexion en tant que root ou un autre utilisateur.


## Traitement des fichiers et des donn√©es

- Pour localiser un fichier par son nom dans le r√©pertoire courant, `find . -iname '*something*'` (ou autres).
Pour trouver un fichier n'importe o√π par son nom, utilisez `locate something` (mais n'oubliez pas que `updatedb` peut ne pas avoir index√© les fichiers r√©cemment cr√©√©s).

- Pour une recherche √† travers les fichiers sources ou fichiers de donn√©es (plus pouss√©e que `grep -r`), utilisez [`ag`](https://github.com/ggreer/the_silver_searcher).

- Pour convertir du HTML en texte brut : `lynx -dump -stdin`.

- Pour convertir du Markdown, du HTML et toutes sortes de formats texte, essayez [`pandoc`](http://pandoc.org).

- Si vous devez manipuler du XML, l'ancien `xmlstarlet` marche bien.

- Pour le JSON, utilisez [`jq`](http://stedolan.github.io/jq/).

- Pour le YAML, utilisez [`shyaml`](https://github.com/0k/shyaml).

- Pour les fichiers Excel ou CSV, [csvkit](https://github.com/onyxfish/csvkit) fournit `in2csv`, `csvcut`, `csvjoin`, `csvgrep`, etc.

- Pour Amazon S3, [`s3cmd`](https://github.com/s3tools/s3cmd) est pratique et [`s4cmd`](https://github.com/bloomreach/s4cmd) est plus rapide.
L'outil d'Amazon [`aws`](https://github.com/aws/aws-cli) et la version am√©lior√©e [`saws`](https://github.com/donnemartin/saws) sont indispensables pour les autres t√¢ches li√©es √† AWS.

- Connaissez `sort` et `uniq`, y compris les options `-u` et `-d` de `uniq` (voir les unilignes plus bas). Voir aussi `comm`.

- Sachez utiliser `cut`, `paste` et `join` pour manipuler les fichiers texte.
Beaucoup de personnes utilisent `cut` mais oublient `join`.

- Connaissez `wc` pour compter les lignes (`-l`), les caract√®res (`-m`), les mots (`-w`) et les octets (`-c`).

- Connaissez `tee` pour copier depuis stdin vers un fichier ou vers stdout, comme dans `ls -al | tee file.txt`.

- Sachez que la locale affecte de nombreux outils en ligne de commande de mani√®re subtile, comme l'ordre pour les tris (collation) et les performances.
La plupart des installateurs Linux d√©finissent la variable `LANG` ou d'autres variables locales d'environnement pour configurer une locale telle que US English.
Mais ayez √† l'esprit que le tri sera modifi√© si vous changez la locale.
Et sachez que les routines i18n peuvent rendre les op√©rations de tri et d'autres commandes *beaucoup* plus lentes.
Dans certains cas (tels que les op√©rations concernant les ensembles et l'unicit√© abord√©es ci-dessous) vous pouvez, sans risque, ignorer compl√®tement les lentes routines i18n et utiliser l'ordre de tri classique fond√© sur les valeurs des octets √† l'aide de `export LC_ALL=C`.

- Apprenez `awk` et `sed` pour de l'analyse de donn√©es √©l√©mentaire.
Par exemple, pour effectuer la somme de tous les nombres de la troisi√®me colonne d'un fichier texte&nbsp;: `awk '{ x += $3 } END { print x}'`.
C'est probablement trois fois plus rapide et trois fois plus petit que son √©quivalent en Python.

- Pour remplacer toutes les occurences d'une cha√Æne de caract√®res dans un ou plusieurs fichiers&nbsp;:
```sh
    perl -pi.bak -e 's/old-string/new-string/g' my-files-*.txt
```

- Pour renommer de multiple fichiers ou effectuer des recherches et des remplacements dans des fichiers, essayez [`repren`](https://github.com/jlevy/repren) (dans certains cas la commande `rename` permet aussi de renommer de multiples fichiers, mais soyez prudent car ses fonctionnalit√©s ne sont pas les m√™mes sur toutes les distributions Linux).
```sh
    # Renomme les r√©pertoires, les fichiers et leurs contenus √† l'aide
    # de la substitution foo -> bar :
    repren --full --preserve-case --from foo --to bar .
    # Restaure des fichiers de sauvegarde √† l'aide de la
    # substitution whatever.bak -> whatever :
    repren --renames --from '(.*)\.bak' --to '\1' *.bak
    # M√™me chose que ci-dessus avec rename s'il est disponible :
    rename 's/\.bak$//' *.bak
```

- Selon sa page de manuel, `rsync` est un outil de duplication de fichiers vraiment rapide et incroyablement polyvalent.
Il est connu pour faire de la synchronisation entre machines, mais est √©galement utile pour un usage local.
Il est aussi l'un des outils [les plus rapides](https://web.archive.org/web/20130929001850/http://linuxnote.net/jianingy/en/linux/a-fast-way-to-remove-huge-number-of-files.html) pour effacer un grand nombre de fichiers&nbsp;:
```sh
    mkdir empty && rsync -r --delete empty/ some-dir && rmdir some-dir
```

- Utilisez `shuf` pour m√©langer ou s√©lectionner al√©atoirement des lignes d'un fichier.

- Sachez les options de `sort`.
Pour les nombres, utilisez `-n`, ou `-h` s'ils sont dans un format lisible par un humain (p.&nbsp;ex. issus de `du -h`).
Comprenez le fonctionnement des cl√©s (`-t` et `-k`).
En particulier, faites attention √† bien √©crire `-k1,1` pour trier seulement selon le premier champ&nbsp;: `-k1` signifie que l'on trie selon la ligne enti√®re.
Le tri stable (`sort -s`) peut s'av√©rer utile.
Par exemple, pour trier d'abord selon le champ 2, puis selon le champ 1, vous pouvez utiliser `sort -k1,1 | sort -s -k2,2`.

- Si jamais vous avez besoin d'√©crire un caract√®re de tabulation dans une ligne de commande en Bash (p.&nbsp;ex pour le param√®tre de l'option de tri `-t`), entrez **ctrl-v** **[Tab]** ou √©crivez `$'\t'` (pr√©f√©rable car vous pouvez le copier-coller).

- Les outils habituels pour *patcher* un code source sont `diff` et `patch`.
Voir aussi `diffstat` pour un relev√© statistique d'un diff et `sdiff` pour un affichage c√¥te √† c√¥te d'un diff.
Remarquez que `diff -r` marche avec des r√©pertoires entiers.
Utilisez `diff -r tree1 tree2 | diffstat` pour obtenir un r√©sum√© des changements.
Utilisez `vimdiff` pour comparer et √©diter des fichiers.

- Pour les fichiers binaires, utilisez `hd`, `hexdump` ou `xxd` pour un affichage simple en hexad√©cimal et `bvi`, `biew` pour √©diter des fichiers binaires.

- √âgalement pour les fichiers binaires, `strings` (ainsi que `grep`, etc) vous permet d'y trouver des bouts de texte.

- Pour effectuer des diff√©rences entre des fichiers binaires (compression diff√©rentielle), utilisez `xdelta3`.

- Pour changer l'encodage d'un texte, essayer `iconv`, ou `uconv` pour un usage plus sophistiqu√© : il permet quelques trucs avanc√©s avec l'Unicode.
Par exemple, cette commande met en minuscules et retire tous les accents (en les d√©veloppant et les √©cartant)&nbsp;:
```sh
      uconv -f utf-8 -t utf-8 -x '::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] >; ::Any-NFC; ' < input.txt > output.txt
```

- Pour d√©couper des fichiers en morceaux, regardez `split` pour un d√©coupage en morceaux de taille donn√©e et `csplit` pour un d√©coupage en morceaux d√©limit√©s par un motif.

- Pour manipuler des dates et des heures, utilisez `dateadd`, `datediff`, `strptime`, etc. fournis par [`dateutils`](http://www.fresse.org/dateutils/).

- Utilisez `zless`, `zmore`, `zcat` et `zgrep` pour op√©rer sur des fichiers compress√©s.


## D√©bogage du syst√®me

- Pour du d√©bogage web, `curl` et `curl -I` sont pratiques, de m√™me que leurs
√©quivalents avec `wget`  ou le plus moderne [`httpie`](https://github.com/jkbrzt/httpie).

- Pour conna√Ætre l'√©tat courant du CPU ou du disque, les outils conventionnels sont `top` (ou `htop` meilleur), `iostat` et `iotop`.
Utilisez `iostat -mxz 15` pour des statistiques de base concernant le CPU, des statistiques d√©taill√©es pour les disques et un aper√ßu des performances.

- Pour des informations sur les connexions r√©seaux, utilisez `netstat` et `ss`.

- Pour un rapide aper√ßu de ce qui se passe dans le syst√®me, `dstat` est particuli√®rement utile.
Pour un aper√ßu plus √©tendu et d√©taill√©, utilisez [`glances`](https://github.com/nicolargo/glances).

- Pour conna√Ætre l'√©tat de la m√©moire, ex√©cutez `free` et `vmstat` et comprenez leurs sorties.
En particulier, ayez √† l'esprit que la valeur du ¬´ cache ¬ª est la m√©moire utilis√©e par le noyau Linux comme cache de fichiers, donc compte comme de la m√©moire ¬´ libre ¬ª.

- Le syst√®me de debogage de Java est une autre paire de manche, cependant un truc simple sur la JVM d'Oracle et quelques autres JVMs consiste √† ex√©cuter `kill -3 <pid>` pour obtenir une trace compl√®te des appels et une empreinte de la m√©moire (y compris des d√©tails sur le ramasse-miettes qui peuvent √™tre hautement instructifs) dans stderr ou des fichiers journaux.
Les commandes `jps`, `jstat`, `jstack` et `jmap` de la JDK sont utiles. L'[outil SJK](https://github.com/aragozin/jvm-tools) est plus avanc√©.

- Utilisez `mtr` comme un `traceroute` am√©lior√© pour identifier les probl√®mes de r√©seau.

- Pour d√©terminer les raisons pour lesquelles un disque est plein, `ncdu` permet de gagner du temps par rapport aux commandes habituelles telles que `du -sh *`.

- Pour trouver quel socket ou processus utilise la bande passante, essayez `iftop` ou `nethogs`.

- L'outil `ab` (fourni avec Apache) est utile pour une v√©rification rapide et grossi√®re des performances d'un serveur web.
Pour des tests de charge plus complexes, essayez `siege`.

- Pour du debogage r√©seau plus s√©rieux : `wireshark`, `tshark` ou `ngrep`.

- Sachez utiliser `strace` et `ltrace`.
Ces commandes peuvent √™tre utiles si un programme fonctionne mal ou plante et que vous n'en connaissez pas la raison, ou si vous voulez vous faire une id√©e des performances.
Remarquez l'option de profilage (`-c`) et la possibilit√© de les attacher √† un processus en cours d'ex√©cution (`-p`).

- Connaissez `ldd` pour afficher les biblioth√®ques partag√©es, etc.

- Sachez comment vous connecter √† un processus en cours d'ex√©cution avec `gdb` et r√©cup√©rer la trace des appels.

- Utilisez `/proc`. C'est parfois incroyablement utile pour r√©soudre des probl√®mes en live.
Exemples&nbsp;: `/proc/cpuinfo`, `/proc/meminfo`, `/proc/cmdline`, `/proc/xxx/cwd`, `/proc/xxx/exe`, `/proc/xxx/fd`, `/proc/xxx/smaps` (o√π `xxx` est l'identifiant du processus ou pid).

- Pour comprendre pourquoi quelque chose a mal tourn√© ant√©rieurement, `sar` peut-√™tre tr√®s utile.
Elle fournit un historique concernant l'usage du CPU, de la m√©moire, du r√©seau, etc.

- Pour une analyse plus approfondie du syst√®me et de ses performances, regardez `stap` ([SystemTap](https://sourceware.org/systemtap/wiki)), [`perf`](https://en.wikipedia.org/wiki/Perf_(Linux) et [`sysdig`](https://github.com/draios/sysdig).

- V√©rifiez quel OS vous utilisez avec `uname` ou `uname -a` (information g√©n√©ral sur la version d'Unix et du noyau) ou `lsb_release -a` (informations sur la distribution Linux).

- Utilisez `dmesg` √† chaque fois que quelque chose de bizarre se produit (pour des probl√®mes li√©s au mat√©riel ou aux drivers).


## Unilignes

Quelques exemples d'assemblages de commandes&nbsp;:

- Il est quelques fois extr√®mement utile de pouvoir faire une intersection, union ou diff√©rence ensemblistes de fichiers texte √† l'aide de `sort` et `uniq`.
Supposez que `a` et `b` soient des fichiers texte ne contenant pas de lignes r√©p√©t√©es.
C'est rapide et fonctionne sur des fichiers de taille quelconque jusqu'√† plusieurs gigaoctets (le tri n'est pas limit√© par la capacit√© m√©moire bien que vous puissiez avoir besoin d'utiliser l'option `-T` si `/tmp` est sur une petite partition racine).
Voyez aussi la remarque √† propos de `LC_ALL` ci-dessus et l'option `-u` de `sort` (omise ci-dessous pour plus de clart√©).
```sh
    cat a b | sort | uniq > c       # c est l'union de a et b
    cat a b | sort | uniq -d > c    # c est l'intersection de a et b
    cat a b b | sort | uniq -u > c  # c est la difference  a - b
```

- Utilisez `grep . *` pour inspecter rapidement les contenus des fichiers d'un rep√©rtoire (chaque ligne est pr√©c√©d√© du nom du fichier) ou `head -100 *` (chaque fichier a un titre).
Cela peut √™tre utile pour des r√©pertoires remplis de fichiers de configuration comme ceux de `/sys`, `/proc`, `/etc`.

- Pour ajouter les nombres de la troisi√®me colonne d'un fichier texte (c'est probablement trois fois plus rapide et trois fois plus petit que son √©quivalent en Python)&nbsp;:
```sh
    awk '{ x += $3 } END { print x }' myfile
```

- Pour visualiser les tailles et les dates des fichiers d'une arborescence, une sorte de `ls -l` r√©cursive, mais plus facile √† lire que `ls -lR`&nbsp;:
```sh
    find . -type f -ls
```

- Supposons que vous ayez un fichier texte comme un fichier journal de serveur web et q'une certaine valeur, comme un param√®tre `acct_id` pr√©sent dans l'URL, figure √† certaines lignes.
Si vous voulez un d√©compte du nombre de requ√™tes pour chaque valeur de `acct_id`&nbsp;:
```sh
    cat access.log | egrep -o 'acct_id=[0-9]+' | cut -d= -f2 | sort | uniq -c | sort -rn
```

- Pour surveiller en permanence tout changement, utilisez `watch`, par exemple v√©rifiez les modifications dans les fichiers d'un r√©pertoire avec `watch -d -n 2 'ls -rtlh | tail'` ou surveillez les param√®tres de votre r√©seau tout en d√©pannant la configuration de votre wifi avec `watch -d -n 2 ifconfig`.

- Ex√©cutez cette fonction pour afficher al√©atoirement une astuce de ce guide (analyse le code en Markdown et en extrait un √©l√©ment d'une des listes)&nbsp;:
```sh
     function taocl() {
        curl -s https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md |
          pandoc -f markdown -t html |
          xmlstarlet fo --html --dropdtd |
          xmlstarlet sel -t -v "(html/body/ul/li[count(p)>0])[$RANDOM mod last()+1]" |
          xmlstarlet unesc | fmt -80
      }
```


## Obscures mais utiles

- `expr` : effectue des operations arithm√©tiques et bool√©enne, et √©value des expressions r√©guli√®res.

- `m4` : simple macro processeur.

- `yes` : affiche une cha√Æne de caract√®res ind√©finiment.

- `cal` : un calendrier sympathique.

- `env` : ex√©cute une commande (utile dans les scripts).

- `printenv` : imprime les variables d'environnement (utile pour le d√©bogage et dans les scripts).

- `look` : trouve les mots anglais (ou les lignes d'un fichier) commen√ßant par une cha√Æne donn√©e.

- `cut`, `paste` and `join` : manipulation des donn√©es.

- `fmt` : formate du texte.

- `pr` : formate un texte en pages ou en colonnes.

- `fold` : coupe des lignes de texte.

- `column` : formate un texte en colonnes align√©es, de largeurs fixes ou en tables.

- `expand` et `unexpand` : convertit les tabulations en espaces et vice-versa.

- `nl` : num√©rote les lignes d'un fichier.

- `seq` : affiche une suite de nombres.

- `bc` : une calculatrice.

- `factor` : factorise des nombres entiers.

- [`gpg`](https://gnupg.org/) : chiffre et signe les fichiers.

- `toe` : table des entr√©es terminfo.

- `nc` : debogage r√©seau et transfert de donn√©es.

- `socat` : relai et r√©acheminement de port TCP (semblable √† `netcat`).

- [`slurm`](https://github.com/mattthias/slurm) : visualisation du trafic r√©seau.

- `dd` : d√©placer les donn√©es entre les fichiers ou les p√©riph√©riques.

- `file` : d√©termine le type d'un fichier

- `tree` : affiche les r√©pertoires et sous-r√©pertoires sous la forme d'un arbre (comme `ls` mais r√©cursivement).

- `stat` : affiche des informations sur un fichier.

- `time`: ex√©cute et chronom√®tre une commande.

- `timeout`: ex√©cute une commande avec une limite de temps et stoppe le processus apr√®s la dur√©e indiqu√©e.

- `lockfile` : cr√©e un fichier s√©maphore qui ne peut √™tre supprim√© que par `rm -f`

- `logrotate` : permet la rotation, la compression et l'envoi des fichiers journaux par courrier √©lectronique.

- `watch` : ex√©cute une commande p√©riodiquement, affiche le r√©sultat et surligne les diff√©rences entre les r√©sultats.

- `tac` : affiche des fichiers √† l'envers.

- `shuf` : s√©lection al√©atoire de lignes d'un fichier.

- `comm` : compare ligne √† ligne deux fichiers tri√©s.

- `pv` : surveille la progression des donn√©es √† travers un tube.

- `hd`, `hexdump`, `xxd`, `biew` et `bvi` : dump et √©dition de fichiers binaires.

- `strings` : extrait du texte de fichiers binaires.

- `tr` : conversion et manipulation de caract√®res.

- `iconv` ou `uconv` : conversion entre diff√©rents encodages de caract√®res.

- `split` et `csplit` : d√©coupage de fichiers.

- `sponge` : lit enti√®rement un flux d'entr√©e avant de l'√©crire. Utile pour lire depuis un fichier puis √©crire dans le m√™me fichier, par exemple&nbsp;: `grep -v something some-file | sponge some-file`

- `units` : conversions d'unit√©s et calculs. Convertit des furlongs par fortnight en twips par blink (voir aussi `/usr/share/units/deifinitions.units`).

- `apg` : g√©n√®re des mots de passe al√©atoires.

- `7z` : compresse des fichiers avec taux de compression √©lev√©.

- `ldd` : affiche des informations sur les biblioth√®ques partag√©es.

- `nm` : affiche les symboles des fichiers objets.

- `ab` : mesure les performances de serveurs web.

- `strace`: trace les appels syst√®me.

- `mtr`: un traceroute am√©lior√© pour d√©bugguer un r√©seau.

- `cssh` : visual concurrent shell

- `rsync` : synchronise des fichiers et des dossiers via SSH ou localement.

- `wireshark` et `tshark`: capture de paquets et d√©pannage r√©seau.

- `ngrep` : grep pour les couches r√©seaux.

- `host` et `dig`: interroge les serveurs DNS.

- `lsof` : process file descriptor and socket info.

- `dstat` : statistiques sur les ressources syst√®me.

- [`glances`](https://github.com/nicolargo/glances): aper√ßu de haut niveau et multi-syst√®mes.

- `iostat` : statistiques sur l'usage du disque.

- `mpstat` : statistiques sur l'usage du CPU.

- `vmstat` : statistiques sur l'usage de la m√©moire.

- `htop` : version am√©lior√©e de top.

- `last` : historique des connexions.

- `w` : montre qui est connect√©.

- `id` : affiche les informations sur un utilisateur et ses groupes.

- `sar` : statistiques sur l'activit√© du syst√®me

- `iftop` ou `nethogs` : utilisation du r√©seau par un socket ou un processus.

- `ss` : statistiques relatives aux sockets.

- `dmesg` : messages lors du d√©marrage et erreurs syst√®me.

- `sysctl` : visualise et configure les param√®tres du noyau Linux √† chaud.

- `hdparm` : manipulation et performances d'un disque SATA ou ATA.

- `lsb_release` : informations sur la distribution Linux.

- `lsblk` : affiche les p√©riph√©riques blocs (une arborescence de vos disques et de leurs partitions).

- `lshw`, `lscpu`, `lspci`, `lsusb`, `dmidecode` : informations sur le mat√©riel, comprenant le CPU, le BIOS, le RAID, la carte graphique, les p√©riph√©riques, etc.

- `lsmod` et `modinfo` : liste les modules du noyau et donne des informations sur un module.

- `fortune`, `ddate` et `sl` : euh, bon, seulement si vous estimez que les locomotives √† vapeur et les citations de Jean-Claude Van Damme sont ¬´ utiles ¬ª.


## Uniquement OS X

Ce qui suit ne s'applique *qu'*√† Mac OS.

- Gestion des paquets avec `brew` (Homebrew) ou `port` (MacPorts).
Ceux-ci peuvent √™tre utilis√©s pour installer sur Mac OS la plupart des commandes mentionn√©es ci-dessus.

- Copier la sortie de n'importe quelle commande dans une application de bureau avec `pbcopy` et coller l'entr√©e d'une commande avec `pbpaste`.

- Pour permettre √† la touche Option de fonctionner comme la touche Alt dans le terminal de Mac OS (comme dans les commandes **alt-b**, **alt-f**, etc), allez dans Pr√©f√©rences -> Profils -> Clavier et s√©lectionner ¬´ Choisir la touche Option comme touche virtuelle ¬ª.

- Pour ouvrir un fichier avec une application de bureau, utilisez `open` ou `open -a /Applications/Whatever.app`.

- Spotlight&nbsp;: recherche de fichiers avec `mdfind` et affichage des m√©tadonn√©es (telles que les informations EXIF d'une photo) avec `mdls`.

- Ayez √† l'esprit que Mac OS d√©rive du syst√®me Unix BSD et que beaucoup de commandes (par exemples `ps`, `ls`, `tail`, `awk`, `sed`) pr√©sentent de l√©g√®res diff√©rences avec leurs versions pour Linux, qui lui est largement influenc√© par System V et les outils GNU.
Vous pouvez souvent faire la distinction gr√¢ce √† l'en-t√™te ¬´ BSD General Commands Manual ¬ª dans les pages de manuel.
Dans certains cas, les versions GNU peuvent √©galement √™tre install√©es (telles que `gawk` et `gsed` pour GNU awk et GNU sed).
Pour √©crire des scripts Bash multi-plateformes √©vitez d'utiliser de telles commandes (par exemple, envisagez d'utiliser Python ou Perl) ou alors testez-les soigneusement.

- Pour obtenir des informations sur la version de Mac OS, utilisez `sw_vers`.


## Autres ressources

- [awesome-shell](https://github.com/alebcay/awesome-shell)&nbsp;: une liste organis√©e d'outils et de ressources pour le shell.
- [awesome-osx-command-line](https://github.com/herrbischoff/awesome-osx-command-line)&nbsp;: un guide plus approfondi sur la ligne de commande pour Mac OS.
- [Strict mode](http://redsymbol.net/articles/unofficial-bash-strict-mode/)&nbsp;: pour √©crire de meilleurs scripts shell.
- [shellcheck](https://github.com/koalaman/shellcheck)&nbsp;: un outil d'analyse statique des scripts shell. L'√©quivalent de lint pour bash, sh et zsh.
- [Filenames and Pathnames in Shell](http://www.dwheeler.com/essays/filenames-in-shell.html)&nbsp;: les points de d√©tail, malheureusement compliqu√©s, sur la mani√®re de manipuler correctement les noms de fichiers dans les scripts shell.


## Avertissement

√Ä l'exception des tr√®s petites t√¢ches, le code est √©crit de sorte que d'autres personnes puissent le lire.
Il n'y a pas de pouvoir sans responsabilit√© : le fait que vous *puissiez* faire quelque chose en Bash ne signifie pas n√©cessairement que vous devriez le faire ! ;)


## Licence

[![Licence Creative Commons](https://i.creativecommons.org/l/by-sa/4.0/88x31.png)](http://creativecommons.org/licenses/by-sa/4.0/)

Ce document est mis √† disposition selon les termes de la [Licence Creative Commons Attribution - Partage dans les m√™mes conditions 4.0 International](http://creativecommons.org/licenses/by-sa/4.0/).
